;
;
;
;
;
;
;
;
;
;
;
;
;
; cigma16 breaks the first line when saving so added above buffer
; algorithms to solve the 0-1 Knapsack Problem.
;
; Given a set of items, each having a positive integer weight and a positive
; integer value, and a maximum weight capacity, compute the maximum value you
; can achieve by either including or excluding items from your solution. 
;

; Main program
;    Sets up registers, calls knapsackRP(), knapsackDP(), prints results and terminates
;
; Register usage
;    R1: N / result
;    R2: W
;    R3: pointer to weights
;    R4: pointer to values
;    R5: constant 0
;    R13: return address
;    R14: stack pointer
; Structure of stack frame
;    1[R14]   origin of next stack frame
;    0[R14]   0 (no previous stack frame)
main ;Line 23
    lea   R14,stack[R0]    ; Initialise stack pointer
    store R0,0[R14]        ; No previous stack frame
    store R14,1[R14]       ; Pointer to beginning of current frame

    load R1,N[R0]          ; R1 := N
    load R2,W[R0]          ; R2 := W
    lea R3,weights[R0]     ; R3 := weights
    lea R4,values[R0]      ; R4 := values
    add R5,R0,R0           ; R5 := constant 0 (= i for knapsackRP)

    ;lea R14,1[R14]         ; Push stack pointer
    ;jal R13,knapsackRP[R0] ; Call the recursive knapsack solution function
    ;lea R14,1[R14]         ; Push stack pointer
    ;jal R13,println[R0]    ; Call the println() function; param in R1
    ;trap R0,R0,R0

    load R1,N[R0]          ; Restore N into R1 after it was overwritten by knapsackRP
    lea R14,1[R14]         ; Push stack pointer
    jal R13,knapsackDP[R0] ; Call the dynamic programming knapsack solution function
    lea R14,1[R14]         ; Push stack pointer
    jal R13,println[R0]    ; Call the println() function; param in R1

    trap R0,R0,R0          ; Terminate

;
; function knapsackRP(N:R1, W:R2, weights:R3, values:R4, i:R5) -> return value:R1
;
; The basic recursive algorithm is:
; int knapsackRP(int N, int W, int weights[], int values[], int i) {
;    if (W == 0 || i >= N) // If out of capacity or out of items
;       return 0;
;    if (weights[i] > W) // If weight of current item above weight limit
;       return knapsackRP(N, W, weights, values, i + 1); // Skip to next item
;
;    // Compute solution if the item is included
;    int takeit = values[i] + knapsackRP(N, W - weights[i], weights, values, i + 1);
;
;    // Compute solution if the item is excluded
;    int leaveit = knapsackRP(N, W, weights, values, i + 1);
;
;    return max(takeit, leaveit);
; }
;
; Stack frame structure:
;    <fill in your stack frame's structure...>
;    4[R14]   result if item taken
;    3[R14]   current W
;    2[R14]   current N
;    1[R14]   return address (R13)
;    0[R14]   pointer to previous stack frame
;
; Register usage:
;    R1: N/result
;    R2: W
;    R3: pointer to weights
;    R4: pointer to values
;    R5: i
;    R6: weights[i] pointer | values[i] pointer| result if taken 
;    R7: weights[i] value
;    R8: values[i] value
;    <fill in your register usage...>
;    R12: comparison results
;    R13: return address
;    R14: stack pointer
knapsackRP
    store R14,0[R14]
    store R13,1[R14]

; if (W==0||i>=N) goto return0
    cmpeq R12,R2,R0
    jumpt R12,return0[R0]
    cmplt R12,R5,R1
    jumpf R12,return0[R0]

; if (weights[i]>W) goto skip
    add R6,R3,R5
    load R7,0[R6]
    cmpgt R12,R6,R2
    jumpt R12,skip[R0]

; else
; take item
    store R1,2[R14]; store current N
    store R2,3[R14]; store current W
    add R6,R0,R4   
    add R6,R6,R5
    load R8,0[R6]  ; values[i]
    sub R2,R2,R7   ; W-weights[i]
    lea R5,1[R5]   ; increment i
    lea R14,4[R14] ; push stack
    jal R13,knapsackRP[R0] ; call knapsackRP as if we take the item
    add R1,R1,R8

; leave item
    load R2,3[R14] ; get current W
    store R1,4[R14]; store result if taken
    load R1,2[R14] ; get current N
    jal R13,knapsackRP[R0]; call knapsackRP as if we don't take the item
    load R6,4[R14] ; get result if taken

    ;if (taken > left) set result to take, then goto return
    cmplt R12,R1,R6
    jumpf R12,return[R0]
    add R1,R6,R0
return
    load R13,1[R14]
    load R14,0[R14]
    jump 0[R13]

return0
    add R1,R0,R0
    jump return[R0]

skip
    lea R5,1[R5]
    store R1,2[R14]; store current N
    store R2,3[R14]; store current W
    lea R14,4[R14]
    jal R13,knapsackRP[R0]
    load R1,2[R14]
    load R2,3[R14]
    jump return[R0]
     

;
; function knapsackDP(N:R1, W:R2, weights:R3, values:R4) -> return value:R1
;
; The dynamic programming algorithm is:
; int knapsackDP(int N, int W, int weights[], int values[]) {
;    int S[N+1][W+1]; // Allocate array as local variable
;
;    for (i = 0; i <= W; i++)
;       S[0][i] = 0; // Solution for 0 items is 0
;
;    for (i = 1; i <= N; i++) // Loop over all items...
;       for (w = 0; w <= W; w++) // and over all intermediate weight limits
;          if (weights[i-1] > w) // If the current item doesn't fit...
;             S[i][w] = S[i-1][w]; // then skip it...
;          else
;             // otherwise, compute the maximum of taking it or leaving it
;             S[i][w] = max(S[i-1][w], S[i-1][w-weights[i-1]] + values[i-1]);
;    return S[N][W];
; }
;
; Stack frame structure:
;    <fill in your stack frame's structure...>
;    1[R14]   return address (R13)
;    0[R14]   pointer to previous stack frame
;
; Register usage:
;    R1: N/result
;    R2: W
;    R3: pointer to weights
;    R4: pointer to values
;    R5: i
;    R6: effective address of S[0][i] | w
;    R7: i - 1 | effective address of S[i][w]
;    R8: effective address of S[i-1][w] | w-weights[i-1]] | values[i-1] | S[i-1][w] | value to store at S[i][w]
;    R9: effective address of S[i-1][w-weights[i-1]] | S[i-1][w-weights[i-1]] + values[i-1] | effective address of S[i][w]
;    R10: constant 1
;    R11: pointer to S
;    R12: comparison results
;    R13: return address
;    R14: stack pointer
knapsackDP
; setup stack frame
     store R5,1[R14]
     store R6,2[R14]
     store R7,3[R14]
     store R8,4[R14]
     store R9,5[R14]
     store R10,6[R14]
     store R11,7[R14]
     store R12,8[R14]

     lea R11,1[R14] ; init S
     add R5,R0,R0   ; init i

; populate solutions of 0 items with 0
loop0
     cmplt R12,R5,R2
     jumpf break0
     add R6,R11,R5
     store R0,0[R16]
     jump loop0

break0
     lea R5,1[R0]

; iterate of the number of items to consider
loopN
     cmplt R12,R5,R1
     jumpf R12,breakN[R0]
     add R6,R0,R0

; iterate of item weights
loopW
     cmplt R12,R6,R2
     jumpf R12,loopN[R0]
     sub R7,R5,R10
     add R8,R7,R3
     store R8,0[R8]
     cmpgt R12,R8,R6
     jumpf R12,else[R0]

; if it doesn't fit, skip it
     ;mul R8,R7,R2
     add R8,R8,R6
     load R8,0[R8]
     mul R7,R5,R2
     add R7,R7,R6
     store R8,0[R7]
     jump loopW[R0]

; otherwise, compute if its better to take it or leave it
else
; calc S[i-1][w-weights[i-1]] + values[i-1]
     add R8,R3,R7
     load R8,0[R8]
     sub R8,R6,R8
     mul R9,R7,R1
     add R9,R9,R8
     add R9,R9,R11
     load R9,0[R9]
     add R8,R4,R7
     load R8,0[R8]
     add R9,R9,R8

; get S[i-1][w]
     mul R8,R7,R1
     add R8,R8,R6
     add R8,R8,R11
     load R8,0[R8]
    
     cmpgt R12,R8,R9
     jumpt R12,store[R0]
     add R8,R9,R0
store
     mul R9,R5,R1
     add R9,R9,R6
     add R9,R9,R11
     store R8,0[R9]
     jump loopW[R0]

breakN
     mul R6,R1,R1
     add R6,R6,R2
     add R6,R6,R11
     store R1,0[R6]     
; cleanup stack
     load R5,1[R14]
     load R6,2[R14]
     load R7,3[R14]
     load R8,4[R14]
     load R9,5[R14]
     load R10,6[R14]
     load R11,7[R14]
     load R12,8[R14]

     load R14,0[R14]
     jump 0[R13]

; Function println(num:R1)
;    Converts the value in R1 to printable decimal digits and prints it on screen
;
; Stack frame structure:
;    (1+(num of base 10 digits))[R14]..(1+(2*(num of base 10 digits)))[R14] charArray
;    8[R14]..(num of base 10 digits)[R14] charStack 
;    1[R14]..7[R14] caller's R2-R6 and R10-R12 registers in that order
;    0[R14]   pointer to previous stack frame
;
; Register usage:
;    R1: input number | current charStack pointer for reversal
;    R2: base to convert to (10) | ASCII LF char (10)
;    R3: length of string
;    R4: minimum charStack pointer
;    R5: modulo value | constant 1 for decrementation of charStack pointer | constant 2 for print trap
;    R6: current stack value
;    R10: string array pointer
;    R11: string stack pointer
;    R12: comparison results
;    R13: return address
;    R14: stack pointer

println
; Setup stack frame
    store R2,1[R14]
    store R3,2[R14]
    store R4,3[R14]
    store R5,4[R14]
    store R6,5[R14]
    store R10,6[R14]
    store R11,7[R14]
    store R12,8[R14]
; Initialise variables for decoding
    lea R11,9[R14] ;init string stack pointer
    lea R2,10[R0]

; Iterate of all powers of ten less than input number, storing the storing the difference
; from input number and the power of ten at string stack point, subtracting said difference
; and incrementing the string length each iteration each iteration
decode 
    cmpgt R12,R2,R1
    jumpt R12,endDecode[R0]
    div R5,R1,R2   ;next 3 lines find R1 % R3
    mul R5,R5,R2
    sub R5,R1,R5
    div R1,R1,R2   ;Remove found modulo from number
    store R5,0[R11]
    lea R11,1[R11] ;Push string stack pointer
    jump decode[R0]
endDecode
    store R1,0[R11];Append last digit
    lea R11,1[R11] ;increment charStack pointer
    sub R3,R11,R14 ;Length of string is the difference in the stack pointer and the pointer to the last digit + 8
    lea R3,-8[R3]
    lea R5,1[R0]
    add R10,R0,R11 ;set initial string array pointer
    add R1,R10,R0  ;set initial stack reversal into array array pointer 
    lea R4,9[R14] ;set minimum string stack pointer

; Iterate in reverse over the string stack, moving each value into string array: inverting the string
flip
    cmpeq R12,R4,R11
    jumpt R12,endFlip[R0]
    sub R11,R11,R5
    load R6,0[R11]
    lea R6,48[R6]
    store R6,0[R1]
    add R1,R1,R5
    jump flip[R0]
endFlip
; Append newline to string array, print string array and return
    add R4,R10,R3
    sub R3,R3,R5
    store R2,0[R4]
    lea R5,2[R0]
    trap R5,R10,R3

; Restore stack frame
    load R2,1[R14]
    load R3,2[R14]
    load R4,3[R14]
    load R5,4[R14]
    load R6,5[R14]
    load R10,6[R14]
    load R11,7[R14]
    load R12,8[R14]
    load R14,0[R14]
    jump 0[R13]
    

; Data segment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; <Copy-paste the provided inputs here; below input provided for testing purposes...> ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
N       data 3
W       data 5
weights data 1
        data 2
        data 3
values  data 4
        data 3
        data 5
stack   data 0
